package com.example.icompile.codegen

import com.example.icompile.ast.*
import com.example.icompile.constrain.Constrainer
import com.example.icompile.visitor.ASTVisitor
import java.util.*


/**
 * The Frame class is used for tracking the frame size as we generated
 * bytecodes; we need the frame size to determine offsets for variables
 */
internal class Frame {
    var size = 0 // size of current frame
        private set
    private val blockSizes =
        Stack<Block>()

    fun openBlock() {
        blockSizes.push(Block())
    }

    fun closeBlock(): Int {
        val bsize = blockSize
        size -= bsize // all items in the current block are gone
        // so decrease the frame size
        blockSizes.pop()
        return bsize
    }

    fun topBlock(): Block {
        return blockSizes.peek() as Block
    }

    fun change(n: Int) {   // change current block size; framesize
        size += n
        topBlock().change(n)
    }

    val blockSize: Int
        get() = topBlock().size

    // If we are embedded 3 blocks deep in the current frame
    // then the blockSizes stack will have 3 items in it,
    // each recording the size of the associated block
    // e.g. consider the following source program segment
    //     int f(int n,int p) {  <- bottom block has formals
    //        int i;             <- next block has i
    //        { int k; int l; int m <- next block has k, l, and m
    //         ...
    //        the blockSizes stack has 2,1,3 with 3 at the top
    //        the framesize is 6 - the sum of all the block sizes
    init {
        openBlock()
    }
}

/**
 * The Block class is used to record the size of the current block
 * Used in tandem with Frame
 */
internal class Block {
    var size = 0
    fun change(n: Int) {
        size += n
    }

}

/**
 * The Codegen class will walk the AST, determine and set variable
 * offsets and generate the bytecodes
 */
class Codegen(t: AST) : ASTVisitor() {
    var t: AST = t
    private var frameSizes // used for tracking the frame sizes;
            : Stack<Frame> = Stack()

    // when we start generating code for a
    // function we'll push a new entry on the
    // stack with init size zero
    var program // program will contain the generated bytecodes
            : Program = Program()
    var labelNum // used for creating new, unique labels
            : Int = 0
    private var lineNo = 1

    /** visit all the nodes in the AST/gen bytecodes
     */
    fun execute(): Program {
        t.accept(this) //
        return program
    }

    private fun topFrame(): Frame {
        if (frameSizes.empty()) println("frames empty")
        return frameSizes.peek() as Frame
    }

    private fun openFrame() {  // open a new frame - we're generating codes for
        // a function declaration
        frameSizes.push(Frame())
    }

    private fun openBlock() {  // open a new block - store local variables
        topFrame().openBlock()
    }

    private fun closeBlock() {  // close the current block (and pop the local
        // variables off the runtime stack
        topFrame().closeBlock()
    }

    private fun closeFrame() {
        frameSizes.pop()
    }

    private fun changeFrame(n: Int) { // change the size of the current frame by the
        // given amount
        topFrame().change(n)
    }

    private fun frameSize(): Int {  // return the current frame size
        return topFrame().size
    }

    private val blockSize: Int
        get() = topFrame().blockSize

    /** <pre>
     * we'll need to create new labels for the bytecode program
     * e.g. the following is legal despite 2 functions with the same name
     * int f(int n) {... {int f() {... x = f()} } ... y = f(5)}
     * we don't want to generate the label f for the start of both functions
     * instead, we'll generate, e.g., f<<0>> and f<<1>>
    </pre> *
     */
    private fun newLabel(label: String): String {  // create a new label from label
        ++labelNum
        return "$label<<$labelNum>>"
    }

    private fun storeop(code: Code) {
/*
        System.out.println("storeop: "+code.toString()+" fs:"+
           top.getSize()+" bs: "+top.getBlockSize());
*/
        val bytecode: Codes.ByteCodes? = code.bytecode
        val change: Int = Codes.frameChange.get(bytecode)!!
        program.storeop(code)
        if (change == Codes.UnknownChange) {  // pop n; args n
            changeFrame(-(code as NumOpcode).num)
        } else {
            changeFrame(change)
        }
    }

    fun genIntrinsicCodes() {
        // generate codes for read/write functions so they're treated
        // as any other function
        val readLabel = "Read"
        val writeLabel = "Write"
        val readTree: AST? = Constrainer.readTree
        val writeTree: AST? = Constrainer.writeTree
        if (readTree != null) {
            readTree.label = readLabel
        }
        storeop(LabelOpcode(Codes.ByteCodes.LABEL, readLabel))
        storeop(Code(Codes.ByteCodes.LINE))
        storeop(FunctionOpcode(Codes.ByteCodes.FUNCTION, readLabel, -1, -1))
        storeop(Code(Codes.ByteCodes.READ))
        storeop(Code(Codes.ByteCodes.RETURN))
        if (writeTree != null) {
            writeTree.label = writeLabel
        }
        storeop(LabelOpcode(Codes.ByteCodes.LABEL, writeLabel))
        val formal: String =
            (writeTree?.getKid(3)?.getKid(1)?.getKid(2) as IdTree?)?.symbol.toString()
        storeop(Code(Codes.ByteCodes.LINE))
        storeop(FunctionOpcode(Codes.ByteCodes.FUNCTION, writeLabel, -1, -1))
        storeop(VarOpcode(Codes.ByteCodes.LOAD, 0, formal))
        // write has one actual arg - in frame offset 0
        storeop(Code(Codes.ByteCodes.WRITE))
        storeop(Code(Codes.ByteCodes.RETURN))
    }

    /** <pre>
     * visit the given program AST:<br></br><br></br>
     *
     * GOTO start   -- branch around codes for the intrinsics
     * generate codes for the intrinsic trees (read/write)
     * LABEL start
     * generate codes for the BLOCK tree
     * HALT
    </pre> *
     * @param t the program tree to visit
     * @return null - we're a visitor so must return a value
     * but the code generator doesn't need any specific value
     */
    override fun visitProgramTree(t: AST?): Any? {
        val startLabel = newLabel("start")
        openFrame()
        storeop(LabelOpcode(Codes.ByteCodes.GOTO, startLabel))
        // branch over intrinsic bytecodes
        genIntrinsicCodes()
        storeop(LabelOpcode(Codes.ByteCodes.LABEL, startLabel))
        t?.getKid(1)?.accept(this)
        storeop(Code(Codes.ByteCodes.HALT))
        closeFrame()
        return null
    }

    /** <pre>
     * Generate codes for the Block tree:<br></br><br></br>
     * codes for the decls and the statements in the block
     * POP n   -- n is the number of local variables; pop them
    </pre> *
     */
    override fun visitBlockTree(t: AST?): Any? {
        //System.out.println("visitBlockTree");
        openBlock()
        visitKids(t!!)
        storeop(NumOpcode(Codes.ByteCodes.POP, blockSize))
        // remove any local variables from runtime stack
        closeBlock()
        return null
    }

    /** <pre>
     * Generate codes for the function declaration; we'll also record
     * the frame offsets for the formal parameters<br></br><br></br>
     * GOTO continue   -- branch around codes for the function
     * LABEL functionLabel
     * generate codes for the function body
     * LIT 0
     * RETURN function
     * LABEL continue
    </pre> *
     */
    override fun visitFunctionDeclTree(t: AST?): Any? {
        //System.out.println("visitFunctionDeclTree");
        val name: AST? = t!!.getKid(2)
        val formals: AST = t.getKid(3)!!
        val block: AST = t.getKid(4)!!
        val funcName: String = (name as IdTree).symbol.toString()
        val funcLabel = newLabel(funcName)
        t.label = funcLabel
        val continueLabel = newLabel("continue")
        storeop(LabelOpcode(Codes.ByteCodes.GOTO, continueLabel))
        openFrame() // track Frame changes within function
        storeop(LabelOpcode(Codes.ByteCodes.LABEL, funcLabel))
        // now record the frame offsets for the formals
        if (t.line !== lineNo) {
            lineNo = t.line
            storeop(NumOpcode(Codes.ByteCodes.LINE, lineNo))
        }
        for (decl in formals.kids) {
            val id: IdTree = decl.getKid(2) as IdTree
            id.frameOffset = frameSize()
            decl.label = id.symbol.toString()
            changeFrame(1) // ensure frame size includes space for variables
        }
        block.accept(this)
        // emit gratis return in case user didn't provide her/his own return
        storeop(VarOpcode(Codes.ByteCodes.LIT, 0, "   GRATIS-RETURN-VALUE"))
        storeop(LabelOpcode(Codes.ByteCodes.RETURN, funcLabel))
        closeFrame()
        if (t.line !== lineNo) {
            lineNo = t.line
            storeop(NumOpcode(Codes.ByteCodes.LINE, lineNo))
        }
        storeop(LabelOpcode(Codes.ByteCodes.LABEL, continueLabel))
        if (t.line !== lineNo) {
            lineNo = t.line
            storeop(NumOpcode(Codes.ByteCodes.LINE, lineNo))
        }
        return null
    }

    fun checkLine() {}

    /** <pre>
     * Generate codes for the call tree:<br></br><br></br>
     *
     * Codes to evaluate the arguments for the function
     * ARGS *n*    where *n* is the number of args
     * CALL functionName
    </pre> *
     */
    override fun visitCallTree(t: AST?): Any? {
        val funcName = (t?.getKid(1) as IdTree?)?.decoration?.label
        val numArgs = t?.kidCount()?.minus(1)
        if (t != null)
            for (kid in 2..t.kidCount()) {
                t.getKid(kid)!!.accept(this)
            }
        numArgs?.let { NumOpcode(Codes.ByteCodes.ARGS, it) }?.let { storeop(it) }

        //used to set up new frame
        funcName?.let { LabelOpcode(Codes.ByteCodes.CALL, it) }?.let { storeop(it) }
        return null
    }

    /** <pre>
     * Generate codes for the Decl tree:<br></br><br></br>
     *
     * LIT 0  -- 0 is the initial value for the variable
     * record the frame offset of this variable for future references
    </pre> *
     */
    override fun visitDeclTree(t: AST?): Any? {
        //System.out.println("visitDeclTree");
        val id: IdTree = t?.getKid(2) as IdTree
        val idLabel: String = id.symbol.toString()
        t.label = idLabel //set label in dcln node
        id.frameOffset = frameSize()
        storeop(VarOpcode(Codes.ByteCodes.LIT, 0, idLabel))
        //reserve space in frame for new variable; init to 0
        return null
    }

    override fun visitIntTypeTree(t: AST?): Any? {
        //System.out.println("visitIntTypeTree");
        return null
    }

    override fun visitBoolTypeTree(t: AST?): Any? {
        //System.out.println("visitBoolTypeTree");
        return null
    }

    override fun visitFormalsTree(t: AST?): Any? {
        //System.out.println("visitFormalsTree");
        return null
    }

    override fun visitActualArgsTree(t: AST?): Any? {
        //System.out.println("visitActualArgsTree");
        return null
    }

    /** <pre>
     * Generate codes for the *If* tree:<br></br><br></br>
     *
     * generate codes for the conditional tree
     * FALSEBRANCH elseLabel
     * generate codes for the *then* tree - 2nd kid
     * GOTO continue
     * LABEL elseLabel
     * generate codes for the *else* tree - 3rd kid
     * LABEL continue
    </pre> *
     */
    override fun visitIfTree(t: AST?): Any? {
        //System.out.println("visitIfTree");
        val elseLabel = newLabel("else")
        val continueLabel = newLabel("continue")
        t?.getKid(1)?.accept(this) // gen code for conditional expr
        storeop(LabelOpcode(Codes.ByteCodes.FALSEBRANCH, elseLabel))
        if (t?.line != lineNo) {
            lineNo = t!!.line
            storeop(NumOpcode(Codes.ByteCodes.LINE, lineNo))
        }
        t.getKid(2)?.accept(this)
        storeop(LabelOpcode(Codes.ByteCodes.GOTO, continueLabel))
        storeop(LabelOpcode(Codes.ByteCodes.LABEL, elseLabel))
        t.getKid(3)?.accept(this)
        if (t.line != lineNo) {
            lineNo = t.line
            storeop(NumOpcode(Codes.ByteCodes.LINE, lineNo))
        }
        storeop(LabelOpcode(Codes.ByteCodes.LABEL, continueLabel))
        if (t.line != lineNo) {
            lineNo = t.line
            storeop(NumOpcode(Codes.ByteCodes.LINE, lineNo))
        }
        return null
    }

    /** <pre>
     * Generate codes for the While tree:<br></br><br></br>
     *
     * LABEL while
     * generate codes for the conditional
     * FALSEBRANCH continue
     * generate codes for the body of the while
     * GOTO while
     * LABEL continue
    </pre> *
     */
    override fun visitWhileTree(t: AST?): Any? {
        //System.out.println("visitWhileTree");
        val continueLabel = newLabel("continue")
        val whileLabel = newLabel("while")
        storeop(LabelOpcode(Codes.ByteCodes.LABEL, whileLabel))
        if (t!!.line != lineNo) {
            lineNo = t.line
            storeop(NumOpcode(Codes.ByteCodes.LINE, lineNo))
        }
        t.getKid(1)?.accept(this)
        storeop(LabelOpcode(Codes.ByteCodes.FALSEBRANCH, continueLabel))
        t.getKid(2)?.accept(this)
        if (t.line != lineNo) {
            lineNo = t.line
            storeop(NumOpcode(Codes.ByteCodes.LINE, lineNo))
        }
        storeop(LabelOpcode(Codes.ByteCodes.GOTO, whileLabel))
        storeop(LabelOpcode(Codes.ByteCodes.LABEL, continueLabel))
        if (t.line != lineNo) {
            lineNo = t.line
            storeop(NumOpcode(Codes.ByteCodes.LINE, lineNo))
        }
        return null
    }

    override fun visitStringTypeTree(t: AST?): Any? {
        return null
    }

    override fun visitStringTree(t: AST?): Any? {
        val num: String =
            (t as StringTree).symbol.toString()
        storeop(StringOpCode(Codes.ByteCodes.LIT, num))
        return null
    }

    /** <pre>
     * Generate codes for the return tree:<br></br><br></br>
     *
     * generate codes for the expression that will be returned
     * RETURN name-of-function
    </pre> *
     */
    override fun visitReturnTree(t: AST?): Any? {
        //System.out.println("visitReturnTree");
        t?.getKid(1)?.accept(this)
        val fct: AST = t?.decoration!!
        storeop(LabelOpcode(Codes.ByteCodes.RETURN, fct.label))
        return null
    }

    /** <pre>
     * Generate codes for the Assign tree:<br></br><br></br>
     *
     * generate codes for the right-hand-side expression
     * STORE *offset-of-variable name-of-variable*
    </pre> *
     */
    override fun visitAssignTree(t: AST?): Any? {

        val id = t?.getKid(1) as IdTree?
        val vname = id?.symbol.toString()
        val addr = (id?.decoration?.getKid(2) as IdTree?)?.frameOffset
        t?.getKid(2)?.accept(this)
        addr?.let { VarOpcode(Codes.ByteCodes.STORE, it, vname) }?.let { storeop(it) }
        return null
    }

    /** <pre>
     * Load a literal value:
     * LIT *n*  n is the value
    </pre> *
     */
    override fun visitIntTree(t: AST?): Any? {
        //System.out.println("visitIntTree");
        val num: Int =
            (t as IntTree).symbol.toString().toInt()
        storeop(NumOpcode(Codes.ByteCodes.LIT, num))
        return null
    }

    /** <pre>
     * Load a variable:
     * LOAD *offset*  -- load variable using the offset recorded in the AST
    </pre> *
     */
    override fun visitIdTree(t: AST?): Any? {
        //System.out.println("visitIdTree");
        val decl = t?.decoration
        val addr = (decl?.getKid(2) as IdTree?)?.frameOffset
        val vname = (t as IdTree).symbol.toString()
        addr?.let { VarOpcode(Codes.ByteCodes.LOAD, it, vname) }?.let { storeop(it) }
        return null
    }

    /** <pre>
     * Generate codes for the relational op tree e.g. t1 == t2<br></br><br></br>
     *
     * generate codes for t1
     * generate codes for t2
     * BOP op    -- op is the indicated relational op
    </pre> *
     */
    override fun visitRelOpTree(t: AST?): Any? {
        //System.out.println("visitRelOpTree");
        val op: String = (t as RelOpTree).symbol.toString()
        t.getKid(1)?.accept(this)
        t.getKid(2)?.accept(this)
        storeop(LabelOpcode(Codes.ByteCodes.BOP, op))
        return null
    }

    /** <pre>
     * Generate codes for the adding op tree e.g. t1 + t2<br></br><br></br>
     *
     * generate codes for t1
     * generate codes for t2
     * BOP op    -- op is the indicated adding op
    </pre> *
     */
    override fun visitAddOpTree(t: AST?): Any? {
        //System.out.println("visitAddOpTree");
        val op: String = (t as AddOpTree).symbol.toString()
        t.getKid(1)?.accept(this)
        t.getKid(2)?.accept(this)
        storeop(LabelOpcode(Codes.ByteCodes.BOP, op))
        return null
    }

    /** <pre>
     * Generate codes for the multiplying op tree e.g. t1 * t2<br></br><br></br>
     *
     * generate codes for t1
     * generate codes for t2
     * BOP op    -- op is the indicated multiplying op
    </pre> *
     */
    override fun visitMultOpTree(t: AST?): Any? {
        //System.out.println("visitMultOpTree");
        val op: String = (t as MultOpTree).symbol.toString()
        t.getKid(1)?.accept(this)
        t.getKid(2)?.accept(this)
        storeop(LabelOpcode(Codes.ByteCodes.BOP, op))
        return null
    }

}